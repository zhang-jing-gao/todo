import { h, Transition, ref, inject, toRef, defineComponent, computed, watch, nextTick, withDirectives } from 'vue';
import { clickoutside } from 'vdirs';
import { createTreeMate } from 'treemate';
import { NInternalSelectMenu } from '../../_internal';
import { createSelectOptions } from './utils';
import { cascaderInjectionKey } from './interface';
import { tmOptions } from '../../select/src/utils';
export default defineComponent({
    name: 'NCascaderSelectMenu',
    props: {
        value: {
            type: [String, Number, Array],
            default: null
        },
        show: Boolean,
        pattern: {
            type: String,
            default: ''
        },
        multiple: Boolean,
        tmNodes: {
            type: Array,
            default: () => []
        },
        filter: {
            type: Function,
            default: (pattern, _, path) => path.some((option) => option.label && ~option.label.indexOf(pattern))
        }
    },
    setup(props) {
        const { isMountedRef, leafOnlyRef, mergedValueRef, mergedClsPrefixRef, mergedThemeRef, syncSelectMenuPosition, closeMenu, handleSelectMenuClickOutside, doUncheck: cascaderDoUncheck, doCheck: cascaderDoCheck
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
         } = inject(cascaderInjectionKey);
        const menuInstRef = ref(null);
        const selectOptionsRef = computed(() => {
            return createSelectOptions(props.tmNodes, leafOnlyRef.value);
        });
        const filteredSelectOptionsRef = computed(() => {
            const { filter, pattern } = props;
            return selectOptionsRef.value
                .filter((option) => {
                return filter(pattern, { label: option.label, value: option.value }, option.path);
            })
                .map((option) => ({
                value: option.value,
                label: option.label
            }));
        });
        const selectTreeMateRef = computed(() => {
            return createTreeMate(filteredSelectOptionsRef.value, tmOptions);
        });
        watch(toRef(props, 'value'), () => {
            void nextTick(() => {
                syncSelectMenuPosition();
            });
        });
        watch(filteredSelectOptionsRef, () => {
            void nextTick(() => {
                syncSelectMenuPosition();
            });
        });
        function handleToggleOption(option) {
            doCheck(option);
        }
        function doCheck(option) {
            if (props.multiple) {
                const { value: mergedValue } = mergedValueRef;
                if (Array.isArray(mergedValue)) {
                    if (!mergedValue.includes(option.value)) {
                        cascaderDoCheck(option.value);
                    }
                    else {
                        cascaderDoUncheck(option.value);
                    }
                }
                else if (mergedValue === null) {
                    cascaderDoCheck(option.value);
                }
            }
            else {
                cascaderDoCheck(option.value);
                // currently the select menu is set to focusable
                // however just leave it here
                closeMenu(true);
            }
        }
        function prev() {
            var _a;
            (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();
        }
        function next() {
            var _a;
            (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.next();
        }
        function enter() {
            var _a;
            if (menuInstRef) {
                const pendingOptionData = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingOption();
                if (pendingOptionData) {
                    doCheck(pendingOptionData);
                }
                return true;
            }
            return false;
        }
        function handleClickOutside(e) {
            handleSelectMenuClickOutside(e);
        }
        const exposedRef = {
            prev,
            next,
            enter
        };
        return Object.assign({ isMounted: isMountedRef, mergedTheme: mergedThemeRef, mergedClsPrefix: mergedClsPrefixRef, menuInstRef, selectTreeMate: selectTreeMateRef, handleToggleOption,
            handleClickOutside }, exposedRef);
    },
    render() {
        const { mergedClsPrefix, isMounted, mergedTheme } = this;
        return (h(Transition, { name: "fade-in-scale-up-transition", appear: isMounted }, {
            default: () => this.show
                ? withDirectives(h(NInternalSelectMenu, { ref: "menuInstRef", clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-cascader-menu`, autoPending: true, themeOverrides: mergedTheme.peerOverrides.InternalSelectMenu, theme: mergedTheme.peers.InternalSelectMenu, treeMate: this.selectTreeMate, multiple: this.multiple, value: this.value, onMenuToggleOption: this.handleToggleOption }), [[clickoutside, this.handleClickOutside]])
                : null
        }));
    }
});
