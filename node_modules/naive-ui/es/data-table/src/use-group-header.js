import { computed } from 'vue';
import { getColKey, createCustomWidthStyle } from './utils';
function getRowsAndCols(columns) {
    const rows = [];
    const cols = [];
    const dataRelatedCols = [];
    const rowItemMap = new WeakMap();
    let maxDepth = -1;
    let totalRowSpan = 0;
    function ensureMaxDepth(columns, currentDepth) {
        if (currentDepth > maxDepth) {
            rows[currentDepth] = [];
            maxDepth = currentDepth;
        }
        for (const column of columns) {
            if ('children' in column) {
                ensureMaxDepth(column.children, currentDepth + 1);
            }
            else {
                cols.push({
                    key: getColKey(column),
                    style: createCustomWidthStyle(column),
                    column
                });
                totalRowSpan += 1;
                dataRelatedCols.push(column);
            }
        }
    }
    ensureMaxDepth(columns, 0);
    function ensureColLayout(columns, currentDepth, parentIsLast) {
        let currentLeafIndex = -1;
        let hideUntilIndex = 0;
        const lastIndex = columns.length - 1;
        columns.forEach((column, index) => {
            var _a;
            if ('children' in column) {
                // do not allow colSpan > 1 for non-leaf th
                const isLast = parentIsLast && index === lastIndex;
                const rowItem = {
                    column,
                    colSpan: 0,
                    rowSpan: 1,
                    isLast
                };
                ensureColLayout(column.children, currentDepth + 1, isLast);
                column.children.forEach((childColumn) => {
                    var _a, _b;
                    rowItem.colSpan += (_b = (_a = rowItemMap.get(childColumn)) === null || _a === void 0 ? void 0 : _a.colSpan) !== null && _b !== void 0 ? _b : 0;
                });
                rowItemMap.set(column, rowItem);
                rows[currentDepth].push(rowItem);
            }
            else {
                currentLeafIndex += 1;
                if (currentLeafIndex < hideUntilIndex) {
                    return;
                }
                let colSpan = 1;
                if ('titleColSpan' in column) {
                    colSpan = (_a = column.titleColSpan) !== null && _a !== void 0 ? _a : 1;
                }
                if (colSpan > 1) {
                    hideUntilIndex = currentLeafIndex + colSpan;
                }
                const isLast = currentLeafIndex + colSpan === totalRowSpan;
                const rowItem = {
                    column,
                    colSpan: colSpan,
                    rowSpan: maxDepth - currentDepth + 1,
                    isLast
                };
                rowItemMap.set(column, rowItem);
                rows[currentDepth].push(rowItem);
            }
        });
    }
    ensureColLayout(columns, 0, true);
    return {
        rows,
        cols,
        dataRelatedCols
    };
}
export function useGroupHeader(props) {
    const rowsAndCols = computed(() => getRowsAndCols(props.columns));
    return {
        rowsRef: computed(() => rowsAndCols.value.rows),
        colsRef: computed(() => rowsAndCols.value.cols),
        dataRelatedColsRef: computed(() => rowsAndCols.value.dataRelatedCols)
    };
}
