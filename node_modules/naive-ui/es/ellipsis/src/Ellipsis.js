import { defineComponent, h, ref, computed, mergeProps } from 'vue';
import { NTooltip } from '../../tooltip';
import { useConfig, useTheme } from '../../_mixins';
import { ellipsisLight } from '../styles';
import style from './styles/index.cssr';
function createLineClampClass(clsPrefix) {
    return `${clsPrefix}-ellipsis--line-clamp`;
}
const ellipsisProps = Object.assign(Object.assign({}, useTheme.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: {
        type: [Boolean, Object],
        default: true
    } });
export default defineComponent({
    name: 'Ellipsis',
    inheritAttrs: false,
    props: ellipsisProps,
    setup(props, { slots, attrs }) {
        const { mergedClsPrefixRef } = useConfig(props);
        const mergedTheme = useTheme('Ellipsis', 'ellipsis', style, ellipsisLight, props, mergedClsPrefixRef);
        const triggerRef = ref(null);
        const tooltipRef = ref(null);
        const expandedRef = ref(false);
        const ellipsisStyleRef = computed(() => {
            const { lineClamp } = props;
            const { value: expanded } = expandedRef;
            const cursor = props.expandTrigger === 'click' ? 'pointer' : '';
            if (lineClamp !== undefined) {
                return {
                    cursor,
                    textOverflow: '',
                    '-webkit-line-clamp': expanded ? '' : lineClamp
                };
            }
            else {
                return {
                    cursor,
                    textOverflow: expanded ? '' : 'ellipsis',
                    '-webkit-line-clamp': ''
                };
            }
        });
        function getTooltipDisabled() {
            const { value: expanded } = expandedRef;
            if (expanded)
                return true;
            const { value: trigger } = triggerRef;
            if (trigger) {
                const { lineClamp } = props;
                // we need to apply style here, since the dom may be updated in
                // nextTick, measure dom size will derive wrong result
                syncEllipsisStyle(trigger);
                if (lineClamp !== undefined) {
                    return trigger.scrollHeight <= trigger.offsetHeight;
                }
                return trigger.scrollWidth <= trigger.offsetWidth;
            }
            return false;
        }
        const handleClickRef = computed(() => {
            return props.expandTrigger === 'click'
                ? () => {
                    var _a;
                    const { value: expanded } = expandedRef;
                    if (expanded) {
                        (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
                    }
                    expandedRef.value = !expanded;
                }
                : undefined;
        });
        const renderTrigger = () => (h("span", Object.assign({}, mergeProps(attrs, {
            class: [
                `${mergedClsPrefixRef.value}-ellipsis`,
                props.lineClamp !== undefined
                    ? createLineClampClass(mergedClsPrefixRef.value)
                    : undefined
            ],
            style: ellipsisStyleRef.value
        }), { ref: "triggerRef", onClick: handleClickRef.value }), slots));
        function syncEllipsisStyle(trigger) {
            if (!trigger)
                return;
            const latestStyle = ellipsisStyleRef.value;
            const lineClampClass = createLineClampClass(mergedClsPrefixRef.value);
            if (props.lineClamp !== undefined) {
                if (!trigger.classList.contains(lineClampClass)) {
                    trigger.classList.add(lineClampClass);
                }
            }
            else {
                if (trigger.classList.contains(lineClampClass)) {
                    trigger.classList.remove(lineClampClass);
                }
            }
            for (const key in latestStyle) {
                // guard can make it a little faster
                if (trigger.style[key] !== latestStyle[key]) {
                    ;
                    trigger.style[key] = latestStyle[key];
                }
            }
        }
        return {
            mergedTheme,
            triggerRef,
            tooltipRef,
            handleClick: handleClickRef,
            renderTrigger,
            getTooltipDisabled
        };
    },
    render() {
        var _a;
        const { tooltip, renderTrigger, $slots } = this;
        if (tooltip) {
            const { mergedTheme } = this;
            return (h(NTooltip, Object.assign({ ref: "tooltipRef", placement: "top" }, tooltip, { getDisabled: this.getTooltipDisabled, theme: mergedTheme.peers.Tooltip, themeOverrides: mergedTheme.peerOverrides.Tooltip }), {
                trigger: renderTrigger,
                default: (_a = $slots.tooltip) !== null && _a !== void 0 ? _a : $slots.default
            }));
        }
        else
            return renderTrigger();
    }
});
