import { h, defineComponent, computed, provide, toRef, mergeProps, ref } from 'vue';
import { useBreakpoint, useMemo } from 'vooks';
import { VResizeObserver } from 'vueuc';
import { pxfy, parseResponsivePropValue, beforeNextFrameOnce } from 'seemly';
import { getSlot, flatten } from '../../_utils';
import { defaultSpan } from './GridItem';
import { useConfig } from '../../_mixins';
const defaultCols = 24;
const gridProps = {
    responsive: {
        type: [String, Boolean],
        default: 'self'
    },
    cols: {
        type: [Number, String],
        default: defaultCols
    },
    collapsed: Boolean,
    // may create grid rows < collapsedRows since a item may take all the row
    collapsedRows: {
        type: Number,
        default: 1
    },
    itemStyle: [Object, String],
    xGap: {
        type: [Number, String],
        default: 0
    },
    yGap: {
        type: [Number, String],
        default: 0
    }
};
export const gridInjectionKey = Symbol('grid');
export default defineComponent({
    name: 'Grid',
    inheritAttrs: false,
    props: gridProps,
    setup(props) {
        const { mergedClsPrefixRef } = useConfig(props);
        const numRegex = /^\d+$/;
        const widthRef = ref(undefined);
        const breakpointRef = useBreakpoint();
        const isResponsiveRef = useMemo(() => {
            if (!numRegex.test(props.cols.toString()))
                return true;
            if (!numRegex.test(props.xGap.toString()))
                return true;
            if (!numRegex.test(props.yGap.toString()))
                return true;
            return false;
        });
        const responsiveQueryRef = computed(() => {
            if (!isResponsiveRef.value)
                return undefined;
            return props.responsive === 'self' ? widthRef.value : breakpointRef.value;
        });
        const responsiveColsRef = useMemo(() => {
            var _a;
            return ((_a = Number(parseResponsivePropValue(props.cols.toString(), responsiveQueryRef.value))) !== null && _a !== void 0 ? _a : defaultCols);
        });
        const responsiveXGapRef = useMemo(() => parseResponsivePropValue(props.xGap.toString(), responsiveQueryRef.value));
        const responsiveYGapRef = useMemo(() => parseResponsivePropValue(props.yGap.toString(), responsiveQueryRef.value));
        const handleResize = (entry) => {
            widthRef.value = entry.contentRect.width;
        };
        const handleResizeRaf = (entry) => {
            beforeNextFrameOnce(handleResize, entry);
        };
        const overflowRef = ref(false);
        const handleResizeRef = computed(() => {
            if (props.responsive === 'self') {
                return handleResizeRaf;
            }
            return undefined;
        });
        provide(gridInjectionKey, {
            itemStyleRef: toRef(props, 'itemStyle'),
            xGapRef: responsiveXGapRef,
            overflowRef
        });
        return {
            mergedClsPrefix: mergedClsPrefixRef,
            style: computed(() => {
                return {
                    width: '100%',
                    display: 'grid',
                    gridTemplateColumns: `repeat(${responsiveColsRef.value}, minmax(0, 1fr))`,
                    columnGap: pxfy(responsiveXGapRef.value),
                    rowGap: pxfy(responsiveYGapRef.value)
                };
            }),
            responsiveQuery: responsiveQueryRef,
            responsiveCols: responsiveColsRef,
            handleResize: handleResizeRef,
            overflow: overflowRef
        };
    },
    render() {
        const renderContent = () => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            this.overflow = false;
            // render will be called twice when mounted, I can't figure out why
            // 2 jobs will be pushed into job queues with same id, and then be flushed
            const children = flatten(getSlot(this));
            const { collapsed, collapsedRows, responsiveCols, responsiveQuery } = this;
            let suffixSpan = 0;
            const maybeSuffixNode = children[children.length - 1];
            if (maybeSuffixNode === null || maybeSuffixNode === void 0 ? void 0 : maybeSuffixNode.props) {
                const suffixPropValue = (_a = maybeSuffixNode.props) === null || _a === void 0 ? void 0 : _a.suffix;
                if (suffixPropValue !== undefined && suffixPropValue !== false) {
                    suffixSpan = (_c = (_b = maybeSuffixNode.props) === null || _b === void 0 ? void 0 : _b.span) !== null && _c !== void 0 ? _c : defaultSpan;
                    maybeSuffixNode.props.privateColStart =
                        responsiveCols + 1 - suffixSpan;
                    maybeSuffixNode.props.privateShow = true;
                }
            }
            let spanCounter = 0;
            let done = false;
            for (const child of children) {
                // @ts-expect-error
                if (((_d = child === null || child === void 0 ? void 0 : child.type) === null || _d === void 0 ? void 0 : _d.__GRID_ITEM__) !== true)
                    continue;
                if (done) {
                    this.overflow = true;
                }
                if (!done) {
                    const childOffset = Number((_f = parseResponsivePropValue((_e = child.props) === null || _e === void 0 ? void 0 : _e.offset, responsiveQuery)) !== null && _f !== void 0 ? _f : 0);
                    const childSpan = Math.min(Number((_h = parseResponsivePropValue((_g = child.props) === null || _g === void 0 ? void 0 : _g.span, responsiveQuery)) !== null && _h !== void 0 ? _h : defaultSpan) + childOffset, responsiveCols) || 1;
                    if (!child.props) {
                        child.props = {
                            privateSpan: childSpan,
                            privateOffset: childOffset
                        };
                    }
                    else {
                        child.props.privateSpan = childSpan;
                        child.props.privateOffset = childOffset;
                    }
                    if (collapsed) {
                        const remainder = spanCounter % responsiveCols;
                        if (childSpan + remainder > responsiveCols) {
                            spanCounter += responsiveCols - remainder;
                        }
                        if (childSpan + spanCounter + suffixSpan >
                            collapsedRows * responsiveCols) {
                            done = true;
                        }
                        else {
                            spanCounter += childSpan;
                        }
                    }
                }
                if (done) {
                    if (child.props) {
                        if (child.props.privateShow !== true) {
                            child.props.privateShow = false;
                        }
                    }
                    else {
                        child.props = {
                            privateShow: false
                        };
                    }
                }
            }
            return h('div', mergeProps({
                class: `${this.mergedClsPrefix}-grid`,
                style: this.style
            }, this.$attrs), children);
        };
        return this.responsive === 'self' ? (h(VResizeObserver, { onResize: this.handleResize }, {
            default: renderContent
        })) : (renderContent());
    }
});
