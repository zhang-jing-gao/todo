import { h, ref, computed, createTextVNode, defineComponent, provide, toRef } from 'vue';
import { VBinder, VTarget } from 'vueuc';
import { useMergedState, useCompitable, useIsMounted, useMemo } from 'vooks';
import { call, keep, warn, getFirstSlotVNode } from '../../_utils';
import { useTheme } from '../../_mixins';
import NPopoverBody, { popoverBodyProps } from './PopoverBody';
const bodyPropKeys = Object.keys(popoverBodyProps);
function appendEvents(vNode, events) {
    Object.entries(events).forEach(([key, handler]) => {
        if (!vNode.props)
            vNode.props = {};
        else {
            vNode.props = Object.assign({}, vNode.props);
        }
        const originalHandler = vNode.props[key];
        if (!originalHandler)
            vNode.props[key] = handler;
        else {
            vNode.props[key] = (...args) => {
                originalHandler(...args);
                handler(...args);
            };
        }
    });
}
const textVNodeType = createTextVNode('').type;
export const popoverBaseProps = {
    show: {
        type: Boolean,
        default: undefined
    },
    defaultShow: Boolean,
    showArrow: {
        type: Boolean,
        default: true
    },
    trigger: {
        type: String,
        default: 'hover'
    },
    delay: {
        type: Number,
        default: 100
    },
    duration: {
        type: Number,
        default: 100
    },
    raw: Boolean,
    placement: {
        type: String,
        default: 'top'
    },
    x: Number,
    y: Number,
    disabled: Boolean,
    getDisabled: Function,
    displayDirective: {
        type: String,
        default: 'if'
    },
    arrowStyle: [String, Object],
    filp: {
        type: Boolean,
        default: true
    },
    animated: {
        type: Boolean,
        default: true
    },
    width: {
        type: [Number, String],
        default: undefined
    },
    overlap: Boolean,
    internalExtraClass: {
        type: Array,
        default: () => []
    },
    onClickoutside: Function,
    // events
    'onUpdate:show': [Function, Array],
    onUpdateShow: [Function, Array],
    /** @deprecated */
    onShow: {
        type: [Function, Array],
        validator: () => {
            warn('popover', '`on-show` is deprecated, please use `on-update:show` instead.');
            return true;
        },
        default: undefined
    },
    /** @deprecated */
    onHide: {
        type: [Function, Array],
        validator: () => {
            warn('popover', '`on-hide` is deprecated, please use `on-update:show` instead.');
            return true;
        },
        default: undefined
    },
    /** @deprecated */
    arrow: {
        type: Boolean,
        default: undefined
    },
    /** @deprecated */
    minWidth: Number,
    /** @deprecated */
    maxWidth: Number
};
const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), { internalRenderBody: Function });
export default defineComponent({
    name: 'Popover',
    inheritAttrs: false,
    props: popoverProps,
    setup(props) {
        const isMountedRef = useIsMounted();
        // setup show
        const controlledShowRef = computed(() => props.show);
        const uncontrolledShowRef = ref(props.defaultShow);
        const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
        const getMergedDisabled = () => {
            if (props.disabled)
                return true;
            const { getDisabled } = props;
            if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled())
                return true;
            return false;
        };
        const getMergedShow = () => {
            if (getMergedDisabled())
                return false;
            return mergedShowWithoutDisabledRef.value;
        };
        // setup show-arrow
        const compatibleShowArrowRef = useCompitable(props, ['arrow', 'showArrow']);
        const mergedShowArrowRef = computed(() => {
            if (props.overlap)
                return false;
            return compatibleShowArrowRef.value;
        });
        // trigger
        let triggerVNode = null;
        // bodyInstance
        let bodyInstance = null;
        const showTimerIdRef = ref(null);
        const hideTimerIdRef = ref(null);
        const positionManuallyRef = useMemo(() => {
            return props.x !== undefined && props.y !== undefined;
        });
        // methods
        function doUpdateShow(value) {
            const { 'onUpdate:show': _onUpdateShow, onUpdateShow, onShow, onHide } = props;
            uncontrolledShowRef.value = value;
            if (_onUpdateShow) {
                call(_onUpdateShow, value);
            }
            if (onUpdateShow) {
                call(onUpdateShow, value);
            }
            if (value && onShow) {
                call(onShow, true);
            }
            if (value && onHide) {
                call(onHide, false);
            }
        }
        function syncPosition() {
            if (bodyInstance) {
                bodyInstance.syncPosition();
            }
        }
        function clearShowTimer() {
            const { value: showTimerId } = showTimerIdRef;
            if (showTimerId) {
                window.clearTimeout(showTimerId);
                showTimerIdRef.value = null;
            }
        }
        function clearHideTimer() {
            const { value: hideTimerId } = hideTimerIdRef;
            if (hideTimerId) {
                window.clearTimeout(hideTimerId);
                hideTimerIdRef.value = null;
            }
        }
        function handleMouseEnter() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === 'hover' && !mergedDisabled) {
                clearHideTimer();
                if (showTimerIdRef.value !== null)
                    return;
                if (getMergedShow())
                    return;
                const delayCallback = () => {
                    doUpdateShow(true);
                    showTimerIdRef.value = null;
                };
                const { delay } = props;
                if (delay === 0) {
                    delayCallback();
                }
                else {
                    showTimerIdRef.value = window.setTimeout(delayCallback, delay);
                }
            }
        }
        function handleMouseLeave() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === 'hover' && !mergedDisabled) {
                clearShowTimer();
                if (hideTimerIdRef.value !== null)
                    return;
                if (!getMergedShow())
                    return;
                const delayedCallback = () => {
                    doUpdateShow(false);
                    hideTimerIdRef.value = null;
                };
                const { duration } = props;
                if (duration === 0) {
                    delayedCallback();
                }
                else {
                    hideTimerIdRef.value = window.setTimeout(delayedCallback, duration);
                }
            }
        }
        // will be called in popover-content
        function handleMouseMoveOutside() {
            handleMouseLeave();
        }
        // will be called in popover-content
        function handleClickOutside(e) {
            var _a;
            if (!getMergedShow())
                return;
            if (props.trigger === 'click') {
                clearShowTimer();
                clearHideTimer();
                doUpdateShow(false);
            }
            (_a = props.onClickoutside) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
        function handleClick() {
            if (props.trigger === 'click' && !getMergedDisabled()) {
                clearShowTimer();
                clearHideTimer();
                const nextShow = !getMergedShow();
                doUpdateShow(nextShow);
            }
        }
        function setShow(value) {
            uncontrolledShowRef.value = value;
        }
        function getTriggerElement() {
            return triggerVNode === null || triggerVNode === void 0 ? void 0 : triggerVNode.el;
        }
        function setBodyInstance(value) {
            bodyInstance = value;
        }
        provide('NPopover', {
            getTriggerElement,
            handleMouseEnter,
            handleMouseLeave,
            handleClickOutside,
            handleMouseMoveOutside,
            setBodyInstance,
            positionManuallyRef: positionManuallyRef,
            isMountedRef: isMountedRef,
            extraClassRef: toRef(props, 'internalExtraClass'),
            internalRenderBodyRef: toRef(props, 'internalRenderBody')
        });
        return {
            positionManually: positionManuallyRef,
            // if to show popover body
            uncontrolledShow: uncontrolledShowRef,
            mergedShowArrow: mergedShowArrowRef,
            getMergedShow,
            setShow,
            handleClick,
            handleMouseEnter,
            handleMouseLeave,
            setTriggerVNode(v) {
                triggerVNode = v;
            },
            syncPosition
        };
    },
    render() {
        const { positionManually } = this;
        const slots = Object.assign({}, this.$slots);
        let triggerVNode;
        if (!positionManually) {
            if (slots.activator) {
                triggerVNode = getFirstSlotVNode(slots, 'activator');
            }
            else {
                triggerVNode = getFirstSlotVNode(slots, 'trigger');
            }
            if (triggerVNode) {
                triggerVNode =
                    triggerVNode.type === textVNodeType
                        ? h('span', [triggerVNode])
                        : triggerVNode;
                appendEvents(triggerVNode, {
                    onClick: this.handleClick,
                    onMouseenter: this.handleMouseEnter,
                    onMouseleave: this.handleMouseLeave
                });
            }
            this.setTriggerVNode(triggerVNode);
        }
        return h(VBinder, null, {
            default: () => {
                const mergedShow = this.getMergedShow();
                return [
                    positionManually
                        ? null
                        : h(VTarget, null, {
                            default: () => triggerVNode
                        }),
                    h(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), { showArrow: this.mergedShowArrow, show: mergedShow })), slots)
                ];
            }
        });
    }
});
