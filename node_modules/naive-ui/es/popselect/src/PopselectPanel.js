import { h, computed, defineComponent, inject, toRef, watch, nextTick } from 'vue';
import { createTreeMate } from 'treemate';
import { tmOptions } from '../../select/src/utils';
import { useConfig } from '../../_mixins';
import { NInternalSelectMenu } from '../../_internal';
import { call, keysOf, warn } from '../../_utils';
import { popselectInjectionKey } from './interface';
export const panelProps = {
    multiple: Boolean,
    value: {
        type: [String, Number, Array],
        default: null
    },
    cancelable: Boolean,
    width: [Number, String],
    options: {
        type: Array,
        default: () => []
    },
    size: {
        type: String,
        default: 'medium'
    },
    scrollable: Boolean,
    'onUpdate:value': [Function, Array],
    onUpdateValue: [Function, Array],
    onMouseenter: Function,
    onMouseleave: Function,
    renderLabel: Function,
    // deprecated
    onChange: {
        type: [Function, Array],
        validator: () => {
            warn('popselect', '`on-change` is deprecated, please use `on-update:value` instead.');
            return true;
        },
        default: undefined
    }
};
export const panelPropKeys = keysOf(panelProps);
export default defineComponent({
    name: 'PopselectPanel',
    props: panelProps,
    setup(props) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const NPopselect = inject(popselectInjectionKey);
        const { mergedClsPrefixRef } = useConfig(props);
        function doUpdateValue(value) {
            const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onChange } = props;
            if (onUpdateValue)
                call(onUpdateValue, value);
            if (_onUpdateValue)
                call(_onUpdateValue, value);
            if (onChange)
                call(onChange, value);
        }
        function handleMenuToggleOption(option) {
            toggle(option.value);
        }
        function toggle(value) {
            if (props.multiple) {
                if (Array.isArray(props.value)) {
                    const validValues = new Set(props.options.map((option) => option.value));
                    const newValue = props.value.filter((v) => validValues.has(v));
                    const index = newValue.findIndex((v) => v === value);
                    if (~index) {
                        newValue.splice(index, 1);
                    }
                    else {
                        newValue.push(value);
                    }
                    doUpdateValue(newValue);
                }
                else {
                    doUpdateValue([value]);
                }
            }
            else {
                if (props.value === value && props.cancelable) {
                    doUpdateValue(null);
                }
                else {
                    doUpdateValue(value);
                    NPopselect.setShow(false);
                }
            }
            void nextTick(() => {
                NPopselect.syncPosition();
            });
        }
        watch(toRef(props, 'options'), () => {
            void nextTick(() => {
                NPopselect.syncPosition();
            });
        });
        return {
            mergedTheme: NPopselect.mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            treeMate: computed(() => {
                return createTreeMate(props.options, tmOptions);
            }),
            handleMenuToggleOption
        };
    },
    render() {
        return (h(NInternalSelectMenu, { clsPrefix: this.mergedClsPrefix, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, multiple: this.multiple, treeMate: this.treeMate, size: this.size, value: this.value, width: this.width, virtualScroll: false, scrollable: this.scrollable, renderLabel: this.renderLabel, onMenuToggleOption: this.handleMenuToggleOption, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseenter }));
    }
});
