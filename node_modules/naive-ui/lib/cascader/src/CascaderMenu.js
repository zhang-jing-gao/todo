"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vue_1 = require("vue");
const vdirs_1 = require("vdirs");
const _internal_1 = require("../../_internal");
const CascaderSubmenu_1 = require("./CascaderSubmenu");
const interface_1 = require("./interface");
const focus_detector_1 = require("../../_internal/focus-detector");
exports.default = vue_1.defineComponent({
    name: 'NCascaderMenu',
    props: {
        value: [String, Number, Array],
        placement: {
            type: String,
            default: 'bottom-start'
        },
        show: Boolean,
        menuModel: {
            type: Array,
            required: true
        },
        loading: Boolean,
        onFocus: {
            type: Function,
            required: true
        },
        onBlur: {
            type: Function,
            required: true
        },
        onKeyup: {
            type: Function,
            required: true
        },
        onMousedown: {
            type: Function,
            required: true
        },
        onTabout: {
            type: Function,
            required: true
        }
    },
    setup(props) {
        const { localeRef, isMountedRef, mergedClsPrefixRef, syncCascaderMenuPosition, handleCascaderMenuClickOutside
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
         } = vue_1.inject(interface_1.cascaderInjectionKey);
        const submenuInstRefs = [];
        const maskInstRef = vue_1.ref(null);
        const selfElRef = vue_1.ref(null);
        vue_1.watch(vue_1.toRef(props, 'value'), () => {
            void vue_1.nextTick(() => {
                syncCascaderMenuPosition();
            });
        });
        vue_1.watch(vue_1.toRef(props, 'menuModel'), () => {
            void vue_1.nextTick(() => {
                syncCascaderMenuPosition();
            });
        });
        function showErrorMessage(label) {
            var _a;
            const { value: { loadingRequiredMessage } } = localeRef;
            (_a = maskInstRef.value) === null || _a === void 0 ? void 0 : _a.showOnce(loadingRequiredMessage(label));
        }
        function handleClickOutside(e) {
            handleCascaderMenuClickOutside(e);
        }
        function handleFocusin(e) {
            const { value: selfEl } = selfElRef;
            if (!selfEl)
                return;
            if (!selfEl.contains(e.relatedTarget)) {
                props.onFocus(e);
            }
        }
        function handleFocusout(e) {
            const { value: selfEl } = selfElRef;
            if (!selfEl)
                return;
            if (!selfEl.contains(e.relatedTarget)) {
                props.onBlur(e);
            }
        }
        const exposedRef = {
            scroll(depth, index, elSize) {
                const submenuInst = submenuInstRefs[depth];
                if (submenuInst) {
                    submenuInst.scroll(index, elSize);
                }
            },
            showErrorMessage
        };
        return Object.assign({ isMounted: isMountedRef, mergedClsPrefix: mergedClsPrefixRef, selfElRef,
            submenuInstRefs,
            maskInstRef,
            handleFocusin,
            handleFocusout,
            handleClickOutside }, exposedRef);
    },
    render() {
        const { submenuInstRefs, mergedClsPrefix, $slots } = this;
        return (vue_1.h(vue_1.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
            default: () => this.show
                ? vue_1.withDirectives(vue_1.h("div", { tabindex: "0", ref: "selfElRef", class: `${mergedClsPrefix}-cascader-menu`, onMousedown: this.onMousedown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.onKeyup, style: {
                        '--col-count': this.menuModel.length
                    } },
                    vue_1.h("div", { class: `${mergedClsPrefix}-cascader-submenu-wrapper` },
                        this.menuModel.map((submenuOptions, index) => {
                            return (vue_1.h(CascaderSubmenu_1.default, { ref: ((instance) => {
                                    if (instance)
                                        submenuInstRefs[index] = instance;
                                }), key: index, tmNodes: submenuOptions, depth: index + 1 }));
                        }),
                        vue_1.h(_internal_1.NBaseMenuMask, { clsPrefix: mergedClsPrefix, ref: "maskInstRef" })),
                    $slots.action ? (vue_1.h("div", { class: `${mergedClsPrefix}-cascader-menu-action`, "data-action": true }, {
                        default: $slots.action
                    })) : null,
                    vue_1.h(focus_detector_1.default, { onFocus: this.onTabout })), [[vdirs_1.clickoutside, this.handleClickOutside]])
                : null
        }));
    }
});
