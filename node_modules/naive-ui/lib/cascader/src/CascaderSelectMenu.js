"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vue_1 = require("vue");
const vdirs_1 = require("vdirs");
const treemate_1 = require("treemate");
const _internal_1 = require("../../_internal");
const utils_1 = require("./utils");
const interface_1 = require("./interface");
const utils_2 = require("../../select/src/utils");
exports.default = vue_1.defineComponent({
    name: 'NCascaderSelectMenu',
    props: {
        value: {
            type: [String, Number, Array],
            default: null
        },
        show: Boolean,
        pattern: {
            type: String,
            default: ''
        },
        multiple: Boolean,
        tmNodes: {
            type: Array,
            default: () => []
        },
        filter: {
            type: Function,
            default: (pattern, _, path) => path.some((option) => option.label && ~option.label.indexOf(pattern))
        }
    },
    setup(props) {
        const { isMountedRef, leafOnlyRef, mergedValueRef, mergedClsPrefixRef, mergedThemeRef, syncSelectMenuPosition, closeMenu, handleSelectMenuClickOutside, doUncheck: cascaderDoUncheck, doCheck: cascaderDoCheck
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
         } = vue_1.inject(interface_1.cascaderInjectionKey);
        const menuInstRef = vue_1.ref(null);
        const selectOptionsRef = vue_1.computed(() => {
            return utils_1.createSelectOptions(props.tmNodes, leafOnlyRef.value);
        });
        const filteredSelectOptionsRef = vue_1.computed(() => {
            const { filter, pattern } = props;
            return selectOptionsRef.value
                .filter((option) => {
                return filter(pattern, { label: option.label, value: option.value }, option.path);
            })
                .map((option) => ({
                value: option.value,
                label: option.label
            }));
        });
        const selectTreeMateRef = vue_1.computed(() => {
            return treemate_1.createTreeMate(filteredSelectOptionsRef.value, utils_2.tmOptions);
        });
        vue_1.watch(vue_1.toRef(props, 'value'), () => {
            void vue_1.nextTick(() => {
                syncSelectMenuPosition();
            });
        });
        vue_1.watch(filteredSelectOptionsRef, () => {
            void vue_1.nextTick(() => {
                syncSelectMenuPosition();
            });
        });
        function handleToggleOption(option) {
            doCheck(option);
        }
        function doCheck(option) {
            if (props.multiple) {
                const { value: mergedValue } = mergedValueRef;
                if (Array.isArray(mergedValue)) {
                    if (!mergedValue.includes(option.value)) {
                        cascaderDoCheck(option.value);
                    }
                    else {
                        cascaderDoUncheck(option.value);
                    }
                }
                else if (mergedValue === null) {
                    cascaderDoCheck(option.value);
                }
            }
            else {
                cascaderDoCheck(option.value);
                // currently the select menu is set to focusable
                // however just leave it here
                closeMenu(true);
            }
        }
        function prev() {
            var _a;
            (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();
        }
        function next() {
            var _a;
            (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.next();
        }
        function enter() {
            var _a;
            if (menuInstRef) {
                const pendingOptionData = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingOption();
                if (pendingOptionData) {
                    doCheck(pendingOptionData);
                }
                return true;
            }
            return false;
        }
        function handleClickOutside(e) {
            handleSelectMenuClickOutside(e);
        }
        const exposedRef = {
            prev,
            next,
            enter
        };
        return Object.assign({ isMounted: isMountedRef, mergedTheme: mergedThemeRef, mergedClsPrefix: mergedClsPrefixRef, menuInstRef, selectTreeMate: selectTreeMateRef, handleToggleOption,
            handleClickOutside }, exposedRef);
    },
    render() {
        const { mergedClsPrefix, isMounted, mergedTheme } = this;
        return (vue_1.h(vue_1.Transition, { name: "fade-in-scale-up-transition", appear: isMounted }, {
            default: () => this.show
                ? vue_1.withDirectives(vue_1.h(_internal_1.NInternalSelectMenu, { ref: "menuInstRef", clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-cascader-menu`, autoPending: true, themeOverrides: mergedTheme.peerOverrides.InternalSelectMenu, theme: mergedTheme.peers.InternalSelectMenu, treeMate: this.selectTreeMate, multiple: this.multiple, value: this.value, onMenuToggleOption: this.handleToggleOption }), [[vdirs_1.clickoutside, this.handleClickOutside]])
                : null
        }));
    }
});
