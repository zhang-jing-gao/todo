"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useGroupHeader = void 0;
const vue_1 = require("vue");
const utils_1 = require("./utils");
function getRowsAndCols(columns) {
    const rows = [];
    const cols = [];
    const dataRelatedCols = [];
    const rowItemMap = new WeakMap();
    let maxDepth = -1;
    let totalRowSpan = 0;
    function ensureMaxDepth(columns, currentDepth) {
        if (currentDepth > maxDepth) {
            rows[currentDepth] = [];
            maxDepth = currentDepth;
        }
        for (const column of columns) {
            if ('children' in column) {
                ensureMaxDepth(column.children, currentDepth + 1);
            }
            else {
                cols.push({
                    key: utils_1.getColKey(column),
                    style: utils_1.createCustomWidthStyle(column),
                    column
                });
                totalRowSpan += 1;
                dataRelatedCols.push(column);
            }
        }
    }
    ensureMaxDepth(columns, 0);
    function ensureColLayout(columns, currentDepth, parentIsLast) {
        let currentLeafIndex = -1;
        let hideUntilIndex = 0;
        const lastIndex = columns.length - 1;
        columns.forEach((column, index) => {
            var _a;
            if ('children' in column) {
                // do not allow colSpan > 1 for non-leaf th
                const isLast = parentIsLast && index === lastIndex;
                const rowItem = {
                    column,
                    colSpan: 0,
                    rowSpan: 1,
                    isLast
                };
                ensureColLayout(column.children, currentDepth + 1, isLast);
                column.children.forEach((childColumn) => {
                    var _a, _b;
                    rowItem.colSpan += (_b = (_a = rowItemMap.get(childColumn)) === null || _a === void 0 ? void 0 : _a.colSpan) !== null && _b !== void 0 ? _b : 0;
                });
                rowItemMap.set(column, rowItem);
                rows[currentDepth].push(rowItem);
            }
            else {
                currentLeafIndex += 1;
                if (currentLeafIndex < hideUntilIndex) {
                    return;
                }
                let colSpan = 1;
                if ('titleColSpan' in column) {
                    colSpan = (_a = column.titleColSpan) !== null && _a !== void 0 ? _a : 1;
                }
                if (colSpan > 1) {
                    hideUntilIndex = currentLeafIndex + colSpan;
                }
                const isLast = currentLeafIndex + colSpan === totalRowSpan;
                const rowItem = {
                    column,
                    colSpan: colSpan,
                    rowSpan: maxDepth - currentDepth + 1,
                    isLast
                };
                rowItemMap.set(column, rowItem);
                rows[currentDepth].push(rowItem);
            }
        });
    }
    ensureColLayout(columns, 0, true);
    return {
        rows,
        cols,
        dataRelatedCols
    };
}
function useGroupHeader(props) {
    const rowsAndCols = vue_1.computed(() => getRowsAndCols(props.columns));
    return {
        rowsRef: vue_1.computed(() => rowsAndCols.value.rows),
        colsRef: vue_1.computed(() => rowsAndCols.value.cols),
        dataRelatedColsRef: vue_1.computed(() => rowsAndCols.value.dataRelatedCols)
    };
}
exports.useGroupHeader = useGroupHeader;
