"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDerivedTimeFromKeyboardEvent = exports.strictParse = exports.dateArray = void 0;
const date_fns_1 = require("date-fns");
function getDerivedTimeFromKeyboardEvent(prevValue, event) {
    const now = date_fns_1.getTime(Date.now());
    if (typeof prevValue !== 'number')
        return now;
    switch (event.code) {
        case 'ArrowUp':
            return date_fns_1.getTime(date_fns_1.addDays(prevValue, -7));
        case 'ArrowDown':
            return date_fns_1.getTime(date_fns_1.addDays(prevValue, 7));
        case 'ArrowRight':
            return date_fns_1.getTime(date_fns_1.addDays(prevValue, 1));
        case 'ArrowLeft':
            return date_fns_1.getTime(date_fns_1.addDays(prevValue, -1));
    }
    return now;
}
exports.getDerivedTimeFromKeyboardEvent = getDerivedTimeFromKeyboardEvent;
function matchDate(sourceTime, patternTime) {
    if (Array.isArray(sourceTime)) {
        return sourceTime.some((time) => date_fns_1.isSameDay(time, patternTime));
    }
    else {
        return date_fns_1.isSameDay(sourceTime, patternTime);
    }
}
function dateItem(time, monthTs, valueTs, currentTs) {
    let inSpan = false;
    let startOfSpan = false;
    let endOfSpan = false;
    if (Array.isArray(valueTs)) {
        if (valueTs[0] < time && time < valueTs[1]) {
            inSpan = true;
        }
        if (matchDate(valueTs[0], time))
            startOfSpan = true;
        if (matchDate(valueTs[1], time))
            endOfSpan = true;
    }
    return {
        dateObject: {
            date: date_fns_1.getDate(time),
            month: date_fns_1.getMonth(time),
            year: date_fns_1.getYear(time)
        },
        inCurrentMonth: date_fns_1.isSameMonth(time, monthTs),
        isCurrentDate: matchDate(currentTs, time),
        inSpan,
        startOfSpan,
        endOfSpan,
        selected: valueTs !== null && matchDate(valueTs, time),
        ts: date_fns_1.getTime(time)
    };
}
/**
 * Given time to display calendar, given the selected time, given current time,
 * return the date array of display time's month.
 */
function dateArray(monthTs, valueTs, currentTs, startDay, strip = false) {
    const displayMonth = date_fns_1.getMonth(monthTs);
    // First day of current month
    let displayMonthIterator = date_fns_1.getTime(date_fns_1.startOfMonth(monthTs));
    // Last day of last month
    let lastMonthIterator = date_fns_1.getTime(date_fns_1.addDays(displayMonthIterator, -1));
    const calendarDays = [];
    let protectLastMonthDateIsShownFlag = !strip;
    while (date_fns_1.getDay(lastMonthIterator) !== startDay ||
        protectLastMonthDateIsShownFlag) {
        calendarDays.unshift(dateItem(lastMonthIterator, monthTs, valueTs, currentTs));
        lastMonthIterator = date_fns_1.getTime(date_fns_1.addDays(lastMonthIterator, -1));
        protectLastMonthDateIsShownFlag = false;
    }
    while (date_fns_1.getMonth(displayMonthIterator) === displayMonth) {
        calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
        displayMonthIterator = date_fns_1.getTime(date_fns_1.addDays(displayMonthIterator, 1));
    }
    const endIndex = strip
        ? calendarDays.length <= 28
            ? 28
            : calendarDays.length <= 35
                ? 35
                : 42
        : 42;
    while (calendarDays.length < endIndex) {
        calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
        displayMonthIterator = date_fns_1.getTime(date_fns_1.addDays(displayMonthIterator, 1));
    }
    return calendarDays;
}
exports.dateArray = dateArray;
function strictParse(string, pattern, backup, option) {
    const result = date_fns_1.parse(string, pattern, backup, option);
    if (!date_fns_1.isValid(result))
        return result;
    else if (date_fns_1.format(result, pattern, option) === string)
        return result;
    else
        return new Date(NaN);
}
exports.strictParse = strictParse;
