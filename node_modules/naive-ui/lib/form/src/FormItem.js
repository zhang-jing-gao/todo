"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formItemPropKeys = exports.formItemProps = void 0;
const vue_1 = require("vue");
const async_validator_1 = require("async-validator");
const lodash_1 = require("lodash");
const seemly_1 = require("seemly");
const use_form_item_1 = require("../../_mixins/use-form-item");
const _mixins_1 = require("../../_mixins");
const _utils_1 = require("../../_utils");
const styles_1 = require("../styles");
const utils_1 = require("./utils");
const Feedbacks_1 = require("./Feedbacks");
const form_item_cssr_1 = require("./styles/form-item.cssr");
const interface_1 = require("./interface");
exports.formItemProps = Object.assign(Object.assign({}, _mixins_1.useTheme.props), { label: {
        type: [String, Boolean],
        default: undefined
    }, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: {
        type: Boolean,
        default: false
    }, rulePath: String, required: {
        type: Boolean,
        default: false
    }, showRequireMark: {
        type: [Boolean, String],
        default: undefined
    }, showFeedback: {
        type: Boolean,
        default: undefined
    }, rule: [Object, Array], size: String, ignorePathChange: {
        type: Boolean,
        default: false
    }, validationStatus: String, feedback: String });
exports.formItemPropKeys = _utils_1.keysOf(exports.formItemProps);
// wrap sync validator
function wrapValidator(validator, async) {
    return (...args) => {
        var _a;
        try {
            const validateResult = validator(...args);
            if ((!async &&
                (typeof validateResult === 'boolean' ||
                    validateResult instanceof Error ||
                    Array.isArray(validateResult))) || // Error[]
                ((_a = validateResult) === null || _a === void 0 ? void 0 : _a.then)) {
                return validateResult;
            }
            else if (validateResult === undefined) {
                return true;
            }
            else {
                _utils_1.warn('form-item/validate', `You return a ${typeof validateResult} ` +
                    'typed value in the validator method, which is not recommended. Please use ' +
                    (async ? '`Promise`' : '`boolean`, `Error` or `Promise`') +
                    ' typed value instead.');
                return true;
            }
        }
        catch (err) {
            _utils_1.warn('form-item/validate', 'An error is catched in the validation, ' +
                "so the validation won't be done. Your callback in `validate` method of " +
                "`n-form` or `n-form-item` won't be called in this validation.");
            console.error(err);
            // If returns undefined, async-validator won't trigger callback
            // so the result will be abandoned, which means not true and not false
            return undefined;
        }
    };
}
exports.default = vue_1.defineComponent({
    name: 'FormItem',
    props: exports.formItemProps,
    setup(props) {
        _utils_1.useInjectionInstanceCollection(interface_1.formItemInstsInjectionKey, 'formItems', vue_1.toRef(props, 'path'));
        const { mergedClsPrefixRef } = _mixins_1.useConfig(props);
        const NForm = vue_1.inject(interface_1.formInjectionKey, null);
        const formItemSizeRefs = utils_1.formItemSize(props);
        const formItemMiscRefs = utils_1.formItemMisc(props);
        const { validationErrored: validationErroredRef } = formItemMiscRefs;
        const { mergedRequired: mergedRequiredRef, mergedRules: mergedRulesRef } = utils_1.formItemRule(props);
        const { mergedSize: mergedSizeRef } = formItemSizeRefs;
        const { mergedLabelPlacement: labelPlacementRef, mergedLabelAlign: labelTextAlignRef } = formItemMiscRefs;
        const explainsRef = vue_1.ref([]);
        const feedbackIdRef = vue_1.ref(seemly_1.createId());
        const hasFeedbackRef = vue_1.computed(() => {
            const { feedback } = props;
            if (feedback !== undefined && feedback !== null)
                return true;
            return explainsRef.value.length;
        });
        const themeRef = _mixins_1.useTheme('Form', 'FormItem', form_item_cssr_1.default, styles_1.formLight, props, mergedClsPrefixRef);
        vue_1.watch(vue_1.toRef(props, 'path'), () => {
            if (props.ignorePathChange)
                return;
            restoreValidation();
        });
        function restoreValidation() {
            explainsRef.value = [];
            validationErroredRef.value = false;
            if (props.feedback) {
                feedbackIdRef.value = seemly_1.createId();
            }
        }
        function handleContentBlur() {
            void internalValidate('blur');
        }
        function handleContentChange() {
            void internalValidate('change');
        }
        function handleContentFocus() {
            void internalValidate('focus');
        }
        function handleContentInput() {
            void internalValidate('input');
        }
        function validate(options, callback) {
            return __awaiter(this, void 0, void 0, function* () {
                /** the following code is for compatibility */
                let trigger;
                let validateCallback;
                let shouldRuleBeApplied;
                let asyncValidatorOptions;
                if (typeof options === 'string') {
                    trigger = options;
                    validateCallback = callback;
                }
                else if (options !== null && typeof options === 'object') {
                    trigger = options.trigger;
                    validateCallback = options.callback;
                    shouldRuleBeApplied = options.shouldRuleBeApplied;
                    asyncValidatorOptions = options.options;
                }
                return yield new Promise((resolve, reject) => {
                    void internalValidate(trigger, shouldRuleBeApplied, asyncValidatorOptions).then(({ valid, errors }) => {
                        if (valid) {
                            if (validateCallback) {
                                validateCallback();
                            }
                            resolve();
                        }
                        else {
                            if (validateCallback) {
                                validateCallback(errors);
                            }
                            // eslint-disable-next-line prefer-promise-reject-errors
                            reject(errors);
                        }
                    });
                });
            });
        }
        const internalValidate = (trigger = null, shouldRuleBeApplied = () => true, options = {
            suppressWarning: true
        }) => __awaiter(this, void 0, void 0, function* () {
            const { path } = props;
            if (!options) {
                options = {};
            }
            else {
                if (!options.first)
                    options.first = props.first;
            }
            const { value: rules } = mergedRulesRef;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const value = NForm ? lodash_1.get(NForm.model, path, null) : undefined;
            const activeRules = (!trigger
                ? rules
                : rules.filter((rule) => {
                    // if (rule.trigger === undefined) return true
                    if (Array.isArray(rule.trigger)) {
                        return rule.trigger.includes(trigger);
                    }
                    else {
                        return rule.trigger === trigger;
                    }
                }))
                .filter(shouldRuleBeApplied)
                .map((rule) => {
                const shallowClonedRule = Object.assign({}, rule);
                if (shallowClonedRule.validator) {
                    shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
                }
                if (shallowClonedRule.asyncValidator) {
                    shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
                }
                return shallowClonedRule;
            });
            if (!activeRules.length) {
                return Promise.resolve({
                    valid: true
                });
            }
            const mergedPath = path !== null && path !== void 0 ? path : '__n_no_path__';
            const validator = new async_validator_1.default({ [mergedPath]: activeRules });
            return new Promise((resolve) => {
                void validator.validate({ [mergedPath]: value }, options, (errors, fields) => {
                    if (errors === null || errors === void 0 ? void 0 : errors.length) {
                        explainsRef.value = errors.map((error) => error.message);
                        validationErroredRef.value = true;
                        resolve({
                            valid: false,
                            errors
                        });
                    }
                    else {
                        restoreValidation();
                        resolve({
                            valid: true
                        });
                    }
                });
            });
        });
        vue_1.provide(use_form_item_1.formItemInjectionKey, {
            path: vue_1.toRef(props, 'path'),
            mergedSize: formItemSizeRefs.mergedSize,
            restoreValidation,
            handleContentBlur,
            handleContentChange,
            handleContentFocus,
            handleContentInput
        });
        const exposedRef = {
            validate,
            restoreValidation,
            internalValidate
        };
        return Object.assign(Object.assign(Object.assign(Object.assign({ mergedClsPrefix: mergedClsPrefixRef, mergedRequired: mergedRequiredRef, hasFeedback: hasFeedbackRef, feedbackId: feedbackIdRef, explains: explainsRef }, formItemMiscRefs), formItemSizeRefs), exposedRef), { cssVars: vue_1.computed(() => {
                var _a;
                const { value: size } = mergedSizeRef;
                const { value: labelPlacement } = labelPlacementRef;
                const direction = labelPlacement === 'top' ? 'vertical' : 'horizontal';
                const { common: { cubicBezierEaseInOut }, self: { labelTextColor, asteriskColor, lineHeight, feedbackTextColor, feedbackTextColorWarning, feedbackTextColorError, feedbackPadding, [_utils_1.createKey('labelHeight', size)]: labelHeight, [_utils_1.createKey('blankHeight', size)]: blankHeight, [_utils_1.createKey('feedbackFontSize', size)]: feedbackFontSize, [_utils_1.createKey('feedbackHeight', size)]: feedbackHeight, [_utils_1.createKey('labelPadding', direction)]: labelPadding, [_utils_1.createKey('labelTextAlign', direction)]: labelTextAlign, [_utils_1.createKey(_utils_1.createKey('labelFontSize', labelPlacement), size)]: labelFontSize } } = themeRef.value;
                let mergedLabelTextAlign = (_a = labelTextAlignRef.value) !== null && _a !== void 0 ? _a : labelTextAlign;
                if (labelPlacement === 'top') {
                    mergedLabelTextAlign =
                        mergedLabelTextAlign === 'right' ? 'flex-end' : 'flex-start';
                }
                const cssVars = {
                    '--bezier': cubicBezierEaseInOut,
                    '--line-height': lineHeight,
                    '--blank-height': blankHeight,
                    '--label-font-size': labelFontSize,
                    '--label-text-align': mergedLabelTextAlign,
                    '--label-height': labelHeight,
                    '--label-padding': labelPadding,
                    '--asterisk-color': asteriskColor,
                    '--label-text-color': labelTextColor,
                    '--feedback-padding': feedbackPadding,
                    '--feedback-font-size': feedbackFontSize,
                    '--feedback-height': feedbackHeight,
                    '--feedback-text-color': feedbackTextColor,
                    '--feedback-text-color-warning': feedbackTextColorWarning,
                    '--feedback-text-color-error': feedbackTextColorError
                };
                return cssVars;
            }) });
    },
    render() {
        const { $slots, mergedClsPrefix } = this;
        return (vue_1.h("div", { class: [
                `${mergedClsPrefix}-form-item`,
                `${mergedClsPrefix}-form-item--${this.mergedSize}-size`,
                `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`,
                this.label === false && `${mergedClsPrefix}-form-item--no-label`
            ], style: this.cssVars },
            this.label || $slots.label ? (vue_1.h("label", { class: `${mergedClsPrefix}-form-item-label`, style: this.mergedLabelStyle },
                this.mergedShowRequireMark !== 'left'
                    ? vue_1.renderSlot($slots, 'label', undefined, () => [this.label])
                    : null,
                (this.mergedShowRequireMark !== undefined
                    ? this.mergedShowRequireMark
                    : this.mergedRequired) ? (vue_1.h("span", { class: `${mergedClsPrefix}-form-item-label__asterisk` }, this.mergedShowRequireMark !== 'left' ? '\u00A0*' : '*\u00A0')) : null,
                this.mergedShowRequireMark === 'left'
                    ? vue_1.renderSlot($slots, 'label', undefined, () => [this.label])
                    : null)) : null,
            vue_1.h("div", { class: [
                    `${mergedClsPrefix}-form-item-blank`,
                    this.mergedValidationStatus &&
                        `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`
                ] }, $slots),
            this.mergedShowFeedback ? (vue_1.h("div", { key: this.feedbackId, class: `${mergedClsPrefix}-form-item-feedback-wrapper` },
                vue_1.h(vue_1.Transition, { name: "fade-down-transition", mode: "out-in" }, {
                    default: () => {
                        const feedbacks = (vue_1.h(Feedbacks_1.default, { clsPrefix: mergedClsPrefix, explains: this.explains, feedback: this.feedback }));
                        const { hasFeedback, mergedValidationStatus } = this;
                        return hasFeedback ? (mergedValidationStatus === 'warning' ? (vue_1.h("div", { key: "controlled-warning", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning` }, feedbacks)) : mergedValidationStatus === 'error' ? (vue_1.h("div", { key: "controlled-error", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error` }, feedbacks)) : mergedValidationStatus === 'success' ? (vue_1.h("div", { key: "controlled-success", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success` }, feedbacks)) : (vue_1.h("div", { key: "controlled-default", class: `${mergedClsPrefix}-form-item-feedback` }, feedbacks))) : null;
                    }
                }))) : null));
    }
});
