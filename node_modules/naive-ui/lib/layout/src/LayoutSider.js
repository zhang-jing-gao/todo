"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vue_1 = require("vue");
const _mixins_1 = require("../../_mixins");
const _utils_1 = require("../../_utils");
const scrollbar_1 = require("../../scrollbar");
const styles_1 = require("../styles");
const layout_sider_cssr_1 = require("./styles/layout-sider.cssr");
const ToggleButton_1 = require("./ToggleButton");
const ToggleBar_1 = require("./ToggleBar");
const interface_1 = require("./interface");
const vooks_1 = require("vooks");
const Layout_1 = require("./Layout");
const layoutSiderProps = {
    position: interface_1.positionProp,
    bordered: Boolean,
    collapsedWidth: {
        type: Number,
        default: 48
    },
    width: {
        type: Number,
        default: 272
    },
    contentStyle: {
        type: [String, Object],
        default: ''
    },
    collapseMode: {
        type: String,
        default: 'transform'
    },
    collapsed: {
        type: Boolean,
        default: undefined
    },
    defaultCollapsed: Boolean,
    showCollapsedContent: {
        type: Boolean,
        default: true
    },
    showTrigger: {
        type: [Boolean, String],
        default: false
    },
    nativeScrollbar: {
        type: Boolean,
        default: true
    },
    duration: {
        type: Number,
        default: 300
    },
    inverted: Boolean,
    scrollbarProps: Object,
    triggerStyle: [String, Object],
    // eslint-disable-next-line vue/prop-name-casing
    'onUpdate:collapsed': [Function, Array],
    onUpdateCollapsed: [Function, Array],
    // deprecated
    onExpand: [Function, Array],
    onCollapse: [Function, Array]
};
exports.default = vue_1.defineComponent({
    name: 'LayoutSider',
    props: Object.assign(Object.assign({}, _mixins_1.useTheme.props), layoutSiderProps),
    setup(props) {
        if (process.env.NODE_ENV !== 'production') {
            const layoutProps = vue_1.inject(Layout_1.layoutInjectionKey);
            if (!layoutProps) {
                _utils_1.warn('layout-sider', 'Layout sider is not allowed to be put outside layout.');
            }
            else {
                if (!layoutProps.hasSider) {
                    _utils_1.warn('layout-sider', "You are putting `n-layout-sider` in a `n-layout` but haven't set `has-sider` on the `n-layout`.");
                }
            }
        }
        const scrollableElRef = vue_1.ref(null);
        const scrollbarInstRef = vue_1.ref(null);
        const styleMaxWidthRef = vue_1.computed(() => {
            return _utils_1.formatLength(mergedCollapsedRef.value ? props.collapsedWidth : props.width);
        });
        const scrollContainerStyleRef = vue_1.computed(() => {
            if (props.collapseMode !== 'transform')
                return {};
            return {
                minWidth: _utils_1.formatLength(props.width)
            };
        });
        const uncontrolledCollapsedRef = vue_1.ref(props.defaultCollapsed);
        const mergedCollapsedRef = vooks_1.useMergedState(vue_1.toRef(props, 'collapsed'), uncontrolledCollapsedRef);
        function scrollTo(options, y) {
            if (props.nativeScrollbar) {
                const { value: scrollableEl } = scrollableElRef;
                if (scrollableEl) {
                    if (y === undefined) {
                        scrollableEl.scrollTo(options);
                    }
                    else {
                        scrollableEl.scrollTo(options, y);
                    }
                }
            }
            else {
                const { value: scrollbarInst } = scrollbarInstRef;
                if (scrollbarInst) {
                    scrollbarInst.scrollTo(options, y);
                }
            }
        }
        function handleTriggerClick() {
            const { 'onUpdate:collapsed': _onUpdateCollapsed, onUpdateCollapsed, 
            // deprecated
            onExpand, onCollapse } = props;
            const { value: collapsed } = mergedCollapsedRef;
            if (onUpdateCollapsed) {
                _utils_1.call(onUpdateCollapsed, !collapsed);
            }
            if (_onUpdateCollapsed) {
                _utils_1.call(_onUpdateCollapsed, !collapsed);
            }
            uncontrolledCollapsedRef.value = !collapsed;
            if (collapsed) {
                if (onExpand)
                    _utils_1.call(onExpand);
            }
            else {
                if (onCollapse)
                    _utils_1.call(onCollapse);
            }
        }
        vue_1.provide(interface_1.layoutSiderInjectionKey, {
            collapsedRef: mergedCollapsedRef,
            collapseModeRef: vue_1.toRef(props, 'collapseMode')
        });
        const { mergedClsPrefixRef } = _mixins_1.useConfig(props);
        const themeRef = _mixins_1.useTheme('Layout', 'LayoutSider', layout_sider_cssr_1.default, styles_1.layoutLight, props, mergedClsPrefixRef);
        const exposedMethods = {
            scrollTo
        };
        return Object.assign({ scrollableElRef,
            scrollbarInstRef, mergedClsPrefix: mergedClsPrefixRef, mergedTheme: themeRef, styleMaxWidth: styleMaxWidthRef, mergedCollapsed: mergedCollapsedRef, scrollContainerStyle: scrollContainerStyleRef, handleTriggerClick, cssVars: vue_1.computed(() => {
                const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
                const { siderToggleButtonColor, siderToggleBarColor, siderToggleBarColorHover } = self;
                const vars = {
                    '--bezier': cubicBezierEaseInOut,
                    '--toggle-button-color': siderToggleButtonColor,
                    '--toggle-bar-color': siderToggleBarColor,
                    '--toggle-bar-color-hover': siderToggleBarColorHover
                };
                if (props.inverted) {
                    vars['--color'] = self.siderColorInverted;
                    vars['--text-color'] = self.textColorInverted;
                    vars['--border-color'] = self.siderBorderColorInverted;
                    vars.__invertScrollbar = self.__invertScrollbar;
                }
                else {
                    vars['--color'] = self.siderColor;
                    vars['--text-color'] = self.textColor;
                    vars['--border-color'] = self.siderBorderColor;
                }
                return vars;
            }) }, exposedMethods);
    },
    render() {
        const { mergedClsPrefix, mergedCollapsed, showTrigger } = this;
        return (vue_1.h("aside", { class: [
                `${mergedClsPrefix}-layout-sider`,
                `${mergedClsPrefix}-layout-sider--${this.position}-positioned`,
                this.bordered && `${mergedClsPrefix}-layout-sider--bordered`,
                mergedCollapsed && `${mergedClsPrefix}-layout-sider--collapsed`,
                (!mergedCollapsed || this.showCollapsedContent) &&
                    `${mergedClsPrefix}-layout-sider--show-content`
            ], style: [
                this.cssVars,
                {
                    maxWidth: this.styleMaxWidth,
                    width: _utils_1.formatLength(this.width)
                }
            ] },
            !this.nativeScrollbar ? (vue_1.h(scrollbar_1.NScrollbar, Object.assign({}, this.scrollbarProps, { ref: "scrollbarInstRef", style: this.scrollContainerStyle, contentStyle: this.contentStyle, theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar, 
                // here is a hack, since in light theme the scrollbar color is dark,
                // we need to invert it in light color...
                builtinThemeOverrides: this.inverted && this.cssVars.__invertScrollbar === 'true'
                    ? {
                        colorHover: 'rgba(255, 255, 255, .4)',
                        color: 'rgba(255, 255, 255, .3)'
                    }
                    : undefined }), this.$slots)) : (vue_1.h("div", { class: `${mergedClsPrefix}-layout-sider-scroll-container`, style: [
                    this.scrollContainerStyle,
                    this.contentStyle,
                    {
                        overflow: 'auto'
                    }
                ], ref: "scrollableElRef" }, this.$slots)),
            showTrigger ? (showTrigger === 'arrow-circle' ? (vue_1.h(ToggleButton_1.default, { clsPrefix: mergedClsPrefix, style: this.triggerStyle, onClick: this.handleTriggerClick })) : (vue_1.h(ToggleBar_1.default, { clsPrefix: mergedClsPrefix, collapsed: mergedCollapsed, style: this.triggerStyle, onClick: this.handleTriggerClick }))) : null));
    }
});
