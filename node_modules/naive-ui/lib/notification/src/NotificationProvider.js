"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.notificationApiInjectionKey = exports.notificationProviderInjectionKey = void 0;
/* eslint-disable @typescript-eslint/no-dynamic-delete */
const vue_1 = require("vue");
const seemly_1 = require("seemly");
const _mixins_1 = require("../../_mixins");
const _utils_1 = require("../../_utils");
const styles_1 = require("../styles");
const NotificationContainer_1 = require("./NotificationContainer");
const NotificationEnvironment_1 = require("./NotificationEnvironment");
const index_cssr_1 = require("./styles/index.cssr");
exports.notificationProviderInjectionKey = Symbol('notificationProvider');
exports.notificationApiInjectionKey = Symbol('notificationApi');
const notificationProviderProps = Object.assign(Object.assign({}, _mixins_1.useTheme.props), { to: [String, Object], scrollable: {
        type: Boolean,
        default: true
    } });
exports.default = vue_1.defineComponent({
    name: 'NotificationProvider',
    props: notificationProviderProps,
    setup(props) {
        const { mergedClsPrefixRef } = _mixins_1.useConfig(props);
        const notificationListRef = vue_1.ref([]);
        const notificationRefs = {};
        function create(options) {
            const key = seemly_1.createId();
            const destroy = () => notificationRefs[key].hide();
            const notificationReactive = vue_1.reactive(Object.assign(Object.assign({}, options), { key,
                destroy, hide: destroy, deactivate: destroy }));
            notificationListRef.value.push(notificationReactive);
            return notificationReactive;
        }
        const apis = ['info', 'success', 'warning', 'error'].map((type) => {
            return (options) => create(Object.assign(Object.assign({}, options), { type }));
        });
        function handleAfterLeave(key) {
            notificationListRef.value.splice(notificationListRef.value.findIndex((notification) => notification.key === key), 1);
        }
        const themeRef = _mixins_1.useTheme('Notification', 'Notification', index_cssr_1.default, styles_1.notificationLight, props, mergedClsPrefixRef);
        const api = {
            create,
            info: apis[0],
            success: apis[1],
            warning: apis[2],
            error: apis[3],
            open
        };
        vue_1.provide(exports.notificationApiInjectionKey, api);
        vue_1.provide(exports.notificationProviderInjectionKey, {
            mergedClsPrefixRef,
            mergedThemeRef: themeRef
        });
        // deprecated
        function open(options) {
            return create(options);
        }
        return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            notificationList: notificationListRef,
            notificationRefs,
            handleAfterLeave
        }, api);
    },
    render() {
        var _a;
        return (vue_1.h(vue_1.Fragment, null,
            vue_1.renderSlot(this.$slots, 'default'),
            this.notificationList.length ? (vue_1.h(vue_1.Teleport, { to: (_a = this.to) !== null && _a !== void 0 ? _a : 'body' },
                vue_1.h(NotificationContainer_1.default, { scrollable: this.scrollable }, {
                    default: () => {
                        return this.notificationList.map((notification) => {
                            return (vue_1.h(NotificationEnvironment_1.default, Object.assign({ ref: ((inst) => {
                                    const refKey = notification.key;
                                    if (inst === null) {
                                        delete this.notificationRefs[refKey];
                                    }
                                    else
                                        this.notificationRefs[refKey] = inst;
                                }) }, _utils_1.omit(notification, [
                                'destroy',
                                'hide',
                                'deactivate'
                            ]), { internalKey: notification.key, onInternalAfterLeave: this.handleAfterLeave })));
                        });
                    }
                }))) : null));
    }
});
