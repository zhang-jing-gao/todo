"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.panelPropKeys = exports.panelProps = void 0;
const vue_1 = require("vue");
const treemate_1 = require("treemate");
const utils_1 = require("../../select/src/utils");
const _mixins_1 = require("../../_mixins");
const _internal_1 = require("../../_internal");
const _utils_1 = require("../../_utils");
const interface_1 = require("./interface");
exports.panelProps = {
    multiple: Boolean,
    value: {
        type: [String, Number, Array],
        default: null
    },
    cancelable: Boolean,
    width: [Number, String],
    options: {
        type: Array,
        default: () => []
    },
    size: {
        type: String,
        default: 'medium'
    },
    scrollable: Boolean,
    'onUpdate:value': [Function, Array],
    onUpdateValue: [Function, Array],
    onMouseenter: Function,
    onMouseleave: Function,
    renderLabel: Function,
    // deprecated
    onChange: {
        type: [Function, Array],
        validator: () => {
            _utils_1.warn('popselect', '`on-change` is deprecated, please use `on-update:value` instead.');
            return true;
        },
        default: undefined
    }
};
exports.panelPropKeys = _utils_1.keysOf(exports.panelProps);
exports.default = vue_1.defineComponent({
    name: 'PopselectPanel',
    props: exports.panelProps,
    setup(props) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const NPopselect = vue_1.inject(interface_1.popselectInjectionKey);
        const { mergedClsPrefixRef } = _mixins_1.useConfig(props);
        function doUpdateValue(value) {
            const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onChange } = props;
            if (onUpdateValue)
                _utils_1.call(onUpdateValue, value);
            if (_onUpdateValue)
                _utils_1.call(_onUpdateValue, value);
            if (onChange)
                _utils_1.call(onChange, value);
        }
        function handleMenuToggleOption(option) {
            toggle(option.value);
        }
        function toggle(value) {
            if (props.multiple) {
                if (Array.isArray(props.value)) {
                    const validValues = new Set(props.options.map((option) => option.value));
                    const newValue = props.value.filter((v) => validValues.has(v));
                    const index = newValue.findIndex((v) => v === value);
                    if (~index) {
                        newValue.splice(index, 1);
                    }
                    else {
                        newValue.push(value);
                    }
                    doUpdateValue(newValue);
                }
                else {
                    doUpdateValue([value]);
                }
            }
            else {
                if (props.value === value && props.cancelable) {
                    doUpdateValue(null);
                }
                else {
                    doUpdateValue(value);
                    NPopselect.setShow(false);
                }
            }
            void vue_1.nextTick(() => {
                NPopselect.syncPosition();
            });
        }
        vue_1.watch(vue_1.toRef(props, 'options'), () => {
            void vue_1.nextTick(() => {
                NPopselect.syncPosition();
            });
        });
        return {
            mergedTheme: NPopselect.mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            treeMate: vue_1.computed(() => {
                return treemate_1.createTreeMate(props.options, utils_1.tmOptions);
            }),
            handleMenuToggleOption
        };
    },
    render() {
        return (vue_1.h(_internal_1.NInternalSelectMenu, { clsPrefix: this.mergedClsPrefix, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, multiple: this.multiple, treeMate: this.treeMate, size: this.size, value: this.value, width: this.width, virtualScroll: false, scrollable: this.scrollable, renderLabel: this.renderLabel, onMenuToggleOption: this.handleMenuToggleOption, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseenter }));
    }
});
