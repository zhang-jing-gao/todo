"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vue_1 = require("vue");
const vooks_1 = require("vooks");
const vueuc_1 = require("vueuc");
const vdirs_1 = require("vdirs");
const date_fns_1 = require("date-fns");
const utils_1 = require("../../date-picker/src/utils");
const icons_1 = require("../../_internal/icons");
const input_1 = require("../../input");
const _internal_1 = require("../../_internal");
const _mixins_1 = require("../../_mixins");
const _utils_1 = require("../../_utils");
const styles_1 = require("../styles");
const Panel_1 = require("./Panel");
const index_cssr_1 = require("./styles/index.cssr");
const interface_1 = require("./interface");
const seemly_1 = require("seemly");
const timePickerProps = Object.assign(Object.assign({}, _mixins_1.useTheme.props), { to: _utils_1.useAdjustedTo.propTo, bordered: {
        type: Boolean,
        default: undefined
    }, defaultValue: {
        type: Number,
        default: null
    }, placeholder: String, placement: {
        type: String,
        default: 'bottom-start'
    }, value: Number, format: {
        type: String,
        default: 'HH:mm:ss'
    }, isHourDisabled: Function, size: String, isMinuteDisabled: Function, isSecondDisabled: Function, clearable: {
        type: Boolean,
        default: false
    }, 
    // eslint-disable-next-line vue/prop-name-casing
    'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onBlur: [Function, Array], onFocus: [Function, Array], 
    // private
    stateful: {
        type: Boolean,
        default: true
    }, showIcon: {
        type: Boolean,
        default: true
    }, disabled: {
        type: Boolean,
        default: false
    }, 
    // deprecated
    onChange: {
        type: [Function, Array],
        validator: () => {
            if (process.env.NODE_ENV !== 'production') {
                _utils_1.warn('time-picker', '`on-change` is deprecated, please use `on-update:value` instead.');
            }
            return true;
        },
        default: undefined
    } });
exports.default = vue_1.defineComponent({
    name: 'TimePicker',
    props: timePickerProps,
    setup(props) {
        const { mergedBorderedRef, mergedClsPrefixRef, namespaceRef } = _mixins_1.useConfig(props);
        const { localeRef, dateLocaleRef } = _mixins_1.useLocale('TimePicker');
        const formItem = _mixins_1.useFormItem(props);
        const themeRef = _mixins_1.useTheme('TimePicker', 'TimePicker', index_cssr_1.default, styles_1.timePickerLight, props, mergedClsPrefixRef);
        const keyboardState = vooks_1.useKeyboard();
        const inputInstRef = vue_1.ref(null);
        const panelInstRef = vue_1.ref(null);
        const uncontrolledValueRef = vue_1.ref(props.defaultValue);
        const controlledValueRef = vue_1.toRef(props, 'value');
        const mergedValueRef = vooks_1.useMergedState(controlledValueRef, uncontrolledValueRef);
        const dateFnsOptionsRef = vue_1.computed(() => {
            return {
                locale: dateLocaleRef.value.locale
            };
        });
        const { value: mergedValue } = mergedValueRef;
        const displayTimeStringRef = vue_1.ref(mergedValue === null
            ? ''
            : date_fns_1.format(mergedValue, props.format, dateFnsOptionsRef.value));
        const activeRef = vue_1.ref(false);
        const memorizedValueRef = vue_1.ref(mergedValue);
        const transitionDisabledRef = vue_1.ref(false);
        const localizedNowRef = vue_1.computed(() => {
            return localeRef.value.now;
        });
        const localizedPlaceholderRef = vue_1.computed(() => {
            if (props.placeholder !== undefined)
                return props.placeholder;
            return localeRef.value.placeholder;
        });
        const localizedNegativeTextRef = vue_1.computed(() => {
            return localeRef.value.negativeText;
        });
        const localizedPositiveTextRef = vue_1.computed(() => {
            return localeRef.value.positiveText;
        });
        const hourInFormatRef = vue_1.computed(() => {
            return /H|h|K|k/.test(props.format);
        });
        const minuteInFormatRef = vue_1.computed(() => {
            return props.format.includes('m');
        });
        const secondInFormatRef = vue_1.computed(() => {
            return props.format.includes('s');
        });
        const isHourInvalidRef = vue_1.computed(() => {
            const { isHourDisabled } = props;
            if (!isHourDisabled)
                return false;
            if (hourValueRef.value === null)
                return false;
            return isHourDisabled(hourValueRef.value);
        });
        const isMinuteInvalidRef = vue_1.computed(() => {
            const { isMinuteDisabled } = props;
            if (!isMinuteDisabled)
                return false;
            const { value: minuteValue } = minuteValueRef;
            const { value: hourValue } = hourValueRef;
            if (minuteValue === null || hourValue === null)
                return false;
            return isMinuteDisabled(minuteValue, hourValue);
        });
        const isSecondInvalidRef = vue_1.computed(() => {
            const { isSecondDisabled } = props;
            if (!isSecondDisabled)
                return false;
            const { value: minuteValue } = minuteValueRef;
            const { value: hourValue } = hourValueRef;
            const { value: secondValue } = secondValueRef;
            if (secondValue === null || minuteValue === null || hourValue === null) {
                return false;
            }
            return isSecondDisabled(secondValue, minuteValue, hourValue);
        });
        const isValueInvalidRef = vue_1.computed(() => {
            return (isHourInvalidRef.value ||
                isMinuteInvalidRef.value ||
                isSecondInvalidRef.value);
        });
        const mergedAttrSizeRef = vue_1.computed(() => {
            return props.format.length + 4;
        });
        const hourValueRef = vue_1.computed(() => {
            const { value } = mergedValueRef;
            if (value === null)
                return null;
            return Number(date_fns_1.format(value, 'HH', dateFnsOptionsRef.value));
        });
        const minuteValueRef = vue_1.computed(() => {
            const { value } = mergedValueRef;
            if (value === null)
                return null;
            return Number(date_fns_1.format(value, 'mm', dateFnsOptionsRef.value));
        });
        const secondValueRef = vue_1.computed(() => {
            const { value } = mergedValueRef;
            if (value === null)
                return null;
            return Number(date_fns_1.format(value, 'ss', dateFnsOptionsRef.value));
        });
        function doChange(value) {
            const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onChange } = props;
            const { nTriggerFormChange, nTriggerFormInput } = formItem;
            if (onUpdateValue)
                _utils_1.call(onUpdateValue, value);
            if (_onUpdateValue)
                _utils_1.call(_onUpdateValue, value);
            if (onChange)
                _utils_1.call(onChange, value);
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
            nTriggerFormInput();
        }
        function doFocus(e) {
            const { onFocus } = props;
            const { nTriggerFormFocus } = formItem;
            if (onFocus)
                _utils_1.call(onFocus, e);
            nTriggerFormFocus();
        }
        function doBlur(e) {
            const { onBlur } = props;
            const { nTriggerFormBlur } = formItem;
            if (onBlur)
                _utils_1.call(onBlur, e);
            nTriggerFormBlur();
        }
        function handleTimeInputClear(e) {
            e.stopPropagation();
            doChange(null);
            deriveInputValue(null);
        }
        function handleFocusDetectorFocus() {
            closePanel({
                returnFocus: true
            });
        }
        function handleMenuKeyDown(e) {
            var _a;
            switch (e.code) {
                case 'Escape':
                    closePanel({
                        returnFocus: true
                    });
                    break;
                case 'Tab':
                    if (keyboardState.shift && e.target === ((_a = panelInstRef.value) === null || _a === void 0 ? void 0 : _a.$el)) {
                        e.preventDefault();
                        closePanel({
                            returnFocus: true
                        });
                    }
                    break;
            }
        }
        function disableTransitionOneTick() {
            transitionDisabledRef.value = true;
            void vue_1.nextTick(() => {
                transitionDisabledRef.value = false;
            });
        }
        function handleTriggerClick(e) {
            if (props.disabled || seemly_1.happensIn(e, 'clear'))
                return;
            if (!activeRef.value) {
                openPanel();
            }
        }
        function handleHourClick(hour) {
            if (mergedValueRef.value === null) {
                doChange(date_fns_1.getTime(date_fns_1.setHours(date_fns_1.startOfHour(new Date()), hour)));
            }
            else {
                doChange(date_fns_1.getTime(date_fns_1.setHours(mergedValueRef.value, hour)));
            }
        }
        function handleMinuteClick(minute) {
            if (mergedValueRef.value === null) {
                doChange(date_fns_1.getTime(date_fns_1.setMinutes(date_fns_1.startOfMinute(new Date()), minute)));
            }
            else {
                doChange(date_fns_1.getTime(date_fns_1.setMinutes(mergedValueRef.value, minute)));
            }
        }
        function handleSecondClick(second) {
            if (mergedValueRef.value === null) {
                doChange(date_fns_1.getTime(date_fns_1.setSeconds(date_fns_1.startOfSecond(new Date()), second)));
            }
            else {
                doChange(date_fns_1.getTime(date_fns_1.setSeconds(mergedValueRef.value, second)));
            }
        }
        function deriveInputValue(time) {
            if (time === undefined)
                time = mergedValueRef.value;
            if (time === null)
                displayTimeStringRef.value = '';
            else {
                displayTimeStringRef.value = date_fns_1.format(time, props.format, dateFnsOptionsRef.value);
            }
        }
        function handleTimeInputFocus(e) {
            if (isInternalFocusSwitch(e))
                return;
            doFocus(e);
        }
        function handleTimeInputBlur(e) {
            var _a;
            if (isInternalFocusSwitch(e))
                return;
            if (activeRef.value) {
                const panelEl = (_a = panelInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;
                if (!(panelEl === null || panelEl === void 0 ? void 0 : panelEl.contains(e.relatedTarget))) {
                    doBlur(e);
                    closePanel({
                        returnFocus: false
                    });
                }
            }
        }
        function handleTimeInputActivate() {
            if (props.disabled)
                return;
            if (!activeRef.value) {
                openPanel();
            }
        }
        function handleTimeInputDeactivate() {
            if (props.disabled)
                return;
            deriveInputValue();
            closePanel({
                returnFocus: false
            });
        }
        function scrollTimer() {
            var _a, _b, _c;
            if (!panelInstRef.value)
                return;
            const { hourScrollRef, minuteScrollRef, secondScrollRef } = panelInstRef.value;
            if (hourScrollRef) {
                const hour = (_a = hourScrollRef.contentRef) === null || _a === void 0 ? void 0 : _a.querySelector('[data-active]');
                if (hour) {
                    hourScrollRef.scrollTo({ top: hour.offsetTop });
                }
            }
            if (minuteScrollRef) {
                const minute = (_b = minuteScrollRef.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector('[data-active]');
                if (minute) {
                    minuteScrollRef.scrollTo({ top: minute.offsetTop });
                }
            }
            if (secondScrollRef) {
                const second = (_c = secondScrollRef.contentRef) === null || _c === void 0 ? void 0 : _c.querySelector('[data-active]');
                if (second) {
                    secondScrollRef.scrollTo({ top: second.offsetTop });
                }
            }
        }
        function isInternalFocusSwitch(e) {
            var _a, _b, _c;
            return !!(((_b = (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef) === null || _b === void 0 ? void 0 : _b.contains(e.relatedTarget)) ||
                ((_c = panelInstRef.value) === null || _c === void 0 ? void 0 : _c.$el.contains(e.relatedTarget)));
        }
        function openPanel() {
            memorizedValueRef.value = mergedValueRef.value;
            activeRef.value = true;
            void vue_1.nextTick(scrollTimer);
        }
        function handleClickOutside(e) {
            var _a, _b;
            if (activeRef.value &&
                !((_b = (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef) === null || _b === void 0 ? void 0 : _b.contains(e.target))) {
                closePanel({
                    returnFocus: false
                });
            }
        }
        function closePanel({ returnFocus }) {
            var _a;
            if (activeRef.value) {
                activeRef.value = false;
                if (returnFocus) {
                    (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
                }
            }
        }
        function handleTimeInputUpdateValue(v) {
            if (v === '') {
                doChange(null);
                return;
            }
            const time = utils_1.strictParse(v, props.format, new Date(), dateFnsOptionsRef.value);
            displayTimeStringRef.value = v;
            if (date_fns_1.isValid(time)) {
                const { value: mergedValue } = mergedValueRef;
                if (mergedValue !== null) {
                    const newTime = date_fns_1.set(mergedValue, {
                        hours: date_fns_1.getHours(time),
                        minutes: date_fns_1.getMinutes(time),
                        seconds: date_fns_1.getSeconds(time)
                    });
                    doChange(date_fns_1.getTime(newTime));
                }
                else {
                    doChange(date_fns_1.getTime(time));
                }
            }
        }
        function handleCancelClick() {
            doChange(memorizedValueRef.value);
            activeRef.value = false;
        }
        function handleNowClick() {
            const now = new Date();
            if (!mergedValueRef.value)
                doChange(date_fns_1.getTime(now));
            else {
                const newValue = date_fns_1.setSeconds(date_fns_1.setMinutes(date_fns_1.setHours(mergedValueRef.value, date_fns_1.getHours(now)), date_fns_1.getMinutes(now)), date_fns_1.getSeconds(now));
                doChange(date_fns_1.getTime(newValue));
            }
        }
        function handleConfirmClick() {
            deriveInputValue();
            closePanel({
                returnFocus: true
            });
        }
        function handleMenuFocusOut(e) {
            if (isInternalFocusSwitch(e))
                return;
            doBlur(e);
            closePanel({
                returnFocus: false
            });
        }
        vue_1.watch(mergedValueRef, (value) => {
            deriveInputValue(value);
            disableTransitionOneTick();
            void vue_1.nextTick(scrollTimer);
        });
        vue_1.watch(activeRef, () => {
            if (isValueInvalidRef.value) {
                doChange(memorizedValueRef.value);
            }
        });
        vue_1.provide(interface_1.timePickerInjectionKey, {
            mergedThemeRef: themeRef,
            mergedClsPrefixRef
        });
        return {
            mergedBordered: mergedBorderedRef,
            mergedClsPrefix: mergedClsPrefixRef,
            namespace: namespaceRef,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            isMounted: vooks_1.useIsMounted(),
            inputInstRef,
            panelInstRef,
            adjustedTo: _utils_1.useAdjustedTo(props),
            active: activeRef,
            localizedNow: localizedNowRef,
            localizedPlaceholder: localizedPlaceholderRef,
            localizedNegativeText: localizedNegativeTextRef,
            localizedPositiveText: localizedPositiveTextRef,
            hourInFormat: hourInFormatRef,
            minuteInFormat: minuteInFormatRef,
            secondInFormat: secondInFormatRef,
            mergedAttrSize: mergedAttrSizeRef,
            displayTimeString: displayTimeStringRef,
            mergedSize: formItem.mergedSizeRef,
            isValueInvalid: isValueInvalidRef,
            isHourInvalid: isHourInvalidRef,
            isMinuteInvalid: isMinuteInvalidRef,
            isSecondInvalid: isSecondInvalidRef,
            transitionDisabled: transitionDisabledRef,
            hourValue: hourValueRef,
            minuteValue: minuteValueRef,
            secondValue: secondValueRef,
            handleTimeInputFocus,
            handleTimeInputBlur,
            handleNowClick,
            handleConfirmClick,
            handleTimeInputUpdateValue,
            handleMenuFocusOut,
            handleCancelClick,
            handleClickOutside,
            handleTimeInputActivate,
            handleTimeInputDeactivate,
            handleHourClick,
            handleMinuteClick,
            handleSecondClick,
            handleTimeInputClear,
            handleFocusDetectorFocus,
            handleMenuKeyDown,
            handleTriggerClick,
            mergedTheme: themeRef,
            triggerCssVars: vue_1.computed(() => {
                const { common: { cubicBezierEaseInOut }, self: { iconColor, iconColorDisabled } } = themeRef.value;
                return {
                    '--icon-color': iconColor,
                    '--icon-color-disabled': iconColorDisabled,
                    '--bezier': cubicBezierEaseInOut
                };
            }),
            cssVars: vue_1.computed(() => {
                const { self: { panelColor, itemTextColor, itemTextColorActive, itemColorHover, panelDividerColor, panelBoxShadow, itemOpacityDisabled, borderRadius, itemFontSize, itemWidth, itemHeight, panelActionPadding }, common: { cubicBezierEaseInOut } } = themeRef.value;
                return {
                    '--bezier': cubicBezierEaseInOut,
                    '--border-radius': borderRadius,
                    '--item-color-hover': itemColorHover,
                    '--item-font-size': itemFontSize,
                    '--item-height': itemHeight,
                    '--item-opacity-disabled': itemOpacityDisabled,
                    '--item-text-color': itemTextColor,
                    '--item-text-color-active': itemTextColorActive,
                    '--item-width': itemWidth,
                    '--panel-action-padding': panelActionPadding,
                    '--panel-box-shadow': panelBoxShadow,
                    '--panel-color': panelColor,
                    '--panel-divider-color': panelDividerColor
                };
            })
        };
    },
    render() {
        const { mergedClsPrefix } = this;
        return (vue_1.h("div", { class: `${mergedClsPrefix}-time-picker`, style: this.triggerCssVars },
            vue_1.h(vueuc_1.VBinder, null, {
                default: () => [
                    vue_1.h(vueuc_1.VTarget, null, {
                        default: () => (vue_1.h(input_1.NInput, { ref: "inputInstRef", value: this.displayTimeString, bordered: this.mergedBordered, passivelyActivated: true, attrSize: this.mergedAttrSize, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, stateful: this.stateful, size: this.mergedSize, placeholder: this.localizedPlaceholder, clearable: this.clearable, disabled: this.disabled, textDecoration: this.isValueInvalid ? 'line-through' : undefined, onFocus: this.handleTimeInputFocus, onBlur: this.handleTimeInputBlur, onActivate: this.handleTimeInputActivate, onDeactivate: this.handleTimeInputDeactivate, onUpdateValue: this.handleTimeInputUpdateValue, onClear: this.handleTimeInputClear, internalDeactivateOnEnter: true, internalForceFocus: this.active, onClick: this.handleTriggerClick }, this.showIcon
                            ? {
                                [this.clearable ? 'clear' : 'suffix']: () => (vue_1.h(_internal_1.NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-time-picker-icon` }, {
                                    default: () => vue_1.h(icons_1.TimeIcon, null)
                                }))
                            }
                            : null))
                    }),
                    vue_1.h(vueuc_1.VFollower, { teleportDisabled: this.adjustedTo === _utils_1.useAdjustedTo.tdkey, show: this.active, to: this.adjustedTo, containerClass: this.namespace, placement: "bottom-start" }, {
                        default: () => (vue_1.h(vue_1.Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                            default: () => this.active
                                ? vue_1.withDirectives(vue_1.h(Panel_1.default, { ref: "panelInstRef", style: this.cssVars, transitionDisabled: this.transitionDisabled, hourValue: this.hourValue, showHour: this.hourInFormat, isHourInvalid: this.isHourInvalid, isHourDisabled: this.isHourDisabled, minuteValue: this.minuteValue, showMinute: this.minuteInFormat, isMinuteInvalid: this.isMinuteInvalid, isMinuteDisabled: this.isMinuteDisabled, secondValue: this.secondValue, showSecond: this.secondInFormat, isSecondInvalid: this.isSecondInvalid, isSecondDisabled: this.isSecondDisabled, isValueInvalid: this.isValueInvalid, nowText: this.localizedNow, confirmText: this.localizedPositiveText, onFocusout: this.handleMenuFocusOut, onKeydown: this.handleMenuKeyDown, onHourClick: this.handleHourClick, onMinuteClick: this.handleMinuteClick, onSecondClick: this.handleSecondClick, onNowClick: this.handleNowClick, onConfirmClick: this.handleConfirmClick, onFocusDetectorFocus: this.handleFocusDetectorFocus }), [[vdirs_1.clickoutside, this.handleClickOutside]])
                                : null
                        }))
                    })
                ]
            })));
    }
});
