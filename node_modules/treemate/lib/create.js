"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTreeMate = void 0;
const check_1 = require("./check");
const utils_1 = require("./utils");
const path_1 = require("./path");
const move_1 = require("./move");
const flatten_1 = require("./flatten");
const contains_1 = require("./contains");
function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {
    const treeNodes = [];
    rawNodes.forEach((rawNode, index) => {
        var _a;
        if (process.env.NODE_ENV !== 'production' && utils_1.isNodeInvalid(rawNode)) {
            console.error('[treemate]: node', rawNode, 'is invalid');
        }
        const treeNode = Object.create(nodeProto);
        treeNode.rawNode = rawNode;
        treeNode.siblings = treeNodes;
        treeNode.level = level;
        treeNode.index = index;
        treeNode.isFirstChild = index === 0;
        treeNode.isLastChild = index + 1 === rawNodes.length;
        treeNode.parent = parent;
        if (!treeNode.ignored) {
            const rawChildren = getChildren(rawNode);
            if (rawChildren !== undefined) {
                treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
            }
        }
        treeNodes.push(treeNode);
        treeNodeMap.set(treeNode.key, treeNode);
        if (!levelTreeNodeMap.has(level))
            levelTreeNodeMap.set(level, []);
        (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);
    });
    return treeNodes;
}
function createTreeMate(rawNodes, options = {}) {
    const treeNodeMap = new Map();
    const levelTreeNodeMap = new Map();
    const { getDisabled = utils_1.isDisabled, getIgnored = utils_1.isIgnored, getChildren = utils_1.defaultGetChildren, getIsGroup = utils_1.isGroup, getKey = utils_1.defaultGetKey } = options;
    const nodeProto = Object.assign({
        get key() {
            // do not pass parent or related things to it
            // the key need to be specified explicitly
            return getKey(this.rawNode);
        },
        get disabled() {
            return getDisabled(this.rawNode);
        },
        get isGroup() {
            return getIsGroup(this.rawNode);
        },
        get isLeaf() {
            return utils_1.isLeaf(this.rawNode);
        },
        get shallowLoaded() {
            return utils_1.isShallowLoaded(this.rawNode);
        },
        get ignored() {
            return getIgnored(this.rawNode);
        },
        contains(node) {
            return contains_1.contains(this, node);
        }
    }, move_1.moveMethods);
    const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);
    function getNode(key) {
        if (key === null || key === undefined)
            return null;
        const tmNode = treeNodeMap.get(key);
        if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
            return tmNode;
        }
        return null;
    }
    function _getNode(key) {
        if (key === null || key === undefined)
            return null;
        const tmNode = treeNodeMap.get(key);
        if (tmNode && !tmNode.ignored) {
            return tmNode;
        }
        return null;
    }
    function getPrev(key, options) {
        const node = _getNode(key);
        if (!node)
            return null;
        return node.getPrev(options);
    }
    function getNext(key, options) {
        const node = _getNode(key);
        if (!node)
            return null;
        return node.getNext(options);
    }
    function getParent(key) {
        const node = _getNode(key);
        if (!node)
            return null;
        return node.getParent();
    }
    function getChild(key) {
        const node = _getNode(key);
        if (!node)
            return null;
        return node.getChild();
    }
    const treemate = {
        treeNodes,
        treeNodeMap,
        levelTreeNodeMap,
        maxLevel: Math.max(...levelTreeNodeMap.keys()),
        getFlattenedNodes(expandedKeys) {
            return flatten_1.flatten(treeNodes, expandedKeys);
        },
        getNode,
        getPrev,
        getNext,
        getParent,
        getChild,
        getFirstAvailableNode() {
            return move_1.getFirstAvailableNode(treeNodes);
        },
        getPath(key, options = {}) {
            return path_1.getPath(key, options, treemate);
        },
        getCheckedKeys(checkedKeys, options = {}) {
            const { cascade = true, leafOnly = false } = options;
            return check_1.getCheckedKeys({
                checkedKeys: utils_1.unwrapCheckedKeys(checkedKeys),
                indeterminateKeys: utils_1.unwrapIndeterminateKeys(checkedKeys),
                cascade,
                leafOnly
            }, treemate);
        },
        check(keysToCheck, checkedKeys, options = {}) {
            const { cascade = true, leafOnly = false } = options;
            return check_1.getCheckedKeys({
                checkedKeys: utils_1.unwrapCheckedKeys(checkedKeys),
                indeterminateKeys: utils_1.unwrapIndeterminateKeys(checkedKeys),
                keysToCheck: keysToCheck === undefined || keysToCheck === null
                    ? []
                    : utils_1.toArray(keysToCheck),
                cascade,
                leafOnly
            }, treemate);
        },
        uncheck(keysToUncheck, checkedKeys, options = {}) {
            const { cascade = true, leafOnly = false } = options;
            return check_1.getCheckedKeys({
                checkedKeys: utils_1.unwrapCheckedKeys(checkedKeys),
                indeterminateKeys: utils_1.unwrapIndeterminateKeys(checkedKeys),
                keysToUncheck: keysToUncheck === null || keysToUncheck === undefined
                    ? []
                    : utils_1.toArray(keysToUncheck),
                cascade,
                leafOnly
            }, treemate);
        },
        getNonLeafKeys(options = {}) {
            return utils_1.getNonLeafKeys(treeNodes, options);
        }
    };
    return treemate;
}
exports.createTreeMate = createTreeMate;
